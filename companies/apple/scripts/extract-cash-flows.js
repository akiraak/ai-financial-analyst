// Apple press-release.htm からキャッシュフローデータを抽出するスクリプト
// "CONDENSED CONSOLIDATED STATEMENTS OF CASH FLOWS" テーブルを解析
// 出力: cash-flows.json

const fs = require('fs');
const path = require('path');
const cheerio = require('cheerio');

const FILINGS_DIR = path.join(__dirname, '..', 'filings');
const OUTPUT_PATH = path.join(__dirname, '..', 'data', 'cash-flows.json');

// CF本体の抽出対象
const CF_ROW_MAPPINGS = [
  { patterns: [/^Cash generated by operating activities$/i], key: 'operatingCashFlow' },
  { patterns: [
    /^Cash generated by.*investing activities$/i,
    /^Cash used in investing activities$/i,
  ], key: 'investingCashFlow' },
  { patterns: [
    /^Cash used in financing activities$/i,
    /^Cash generated by.*financing activities$/i,
  ], key: 'financingCashFlow' },
  { patterns: [/^Payments for acquisition of property, plant and equipment$/i], key: 'capitalExpenditures' },
  { patterns: [/^Repurchases of common stock$/i], key: 'shareRepurchases' },
  { patterns: [/^Payments for dividends/i], key: 'dividendsPaid' },
  { patterns: [/^Depreciation and amortization$/i], key: 'depreciationAndAmortization' },
  { patterns: [/^Share-based compensation expense$/i], key: 'shareBasedCompensation' },
];

function parseNumber(text) {
  if (!text || text === '-' || text === '—') return null;
  let negative = false;
  let cleaned = text.replace(/[$\s\u00a0]/g, '');
  if (cleaned.includes('\u2014') || cleaned.includes('\u2013')) return null;
  if (cleaned.startsWith('(') || cleaned.endsWith(')')) {
    negative = true;
    cleaned = cleaned.replace(/[()]/g, '');
  }
  cleaned = cleaned.replace(/,/g, '');
  const num = parseFloat(cleaned);
  if (isNaN(num)) return null;
  return negative ? -num : num;
}

function extractValues($, row) {
  const cells = $(row).find('td');
  const values = [];
  cells.each((i, cell) => {
    const $cell = $(cell);
    const rawText = $cell.text().trim().replace(/\u00a0/g, '').replace(/\s+/g, '').trim();
    const style = ($cell.attr('style') || '').toLowerCase();
    const isRightAligned = style.includes('text-align:right') || style.includes('text-align: right');
    const isNumeric = /^[\$\d,.\-()\u2014\u2013]+$/.test(rawText) && rawText !== '$' && rawText !== '';
    if ((isRightAligned || isNumeric) && rawText) {
      if (rawText === '$' || rawText === '' || rawText === '-' || rawText === '—') return;
      if (rawText.includes('\u2014') || rawText.includes('\u2013')) return;
      values.push(rawText);
    }
  });
  return values;
}

function getRowLabel($, row) {
  const cells = $(row).find('td');
  let label = '';
  cells.each((i, cell) => {
    const $cell = $(cell);
    const text = $cell.text().trim().replace(/\u00a0/g, ' ').replace(/\s+/g, ' ').trim();
    if (!text || text === ' ') return;
    const style = ($cell.attr('style') || '').toLowerCase();
    const colspan = parseInt($cell.attr('colspan') || '1');
    const isLeftAligned = style.includes('text-align:left') || style.includes('text-align: left');
    if ((isLeftAligned || colspan >= 2) && !label) {
      if (!text.match(/^[\$\d,.\-()\s\u2014\u2013]+$/)) {
        label = text;
      }
    }
  });
  if (!label) {
    cells.each((i, cell) => {
      const text = $(cell).text().trim().replace(/\u00a0/g, ' ').replace(/\s+/g, ' ').trim();
      if (text && !text.match(/^[\$\d,.\-()\s\u2014\u2013%]+$/) && text !== '$' && !label) {
        label = text;
      }
    });
  }
  return label;
}

function findTable(html, title) {
  const titleIdx = html.toUpperCase().indexOf(title.toUpperCase());
  if (titleIdx === -1) return null;
  const before = html.substring(0, titleIdx);
  const lastTableOpen = before.lastIndexOf('<table');
  const lastTableClose = before.lastIndexOf('</table>');
  const titleInsideTable = lastTableOpen > lastTableClose && lastTableOpen !== -1;
  let tableStart;
  if (titleInsideTable) {
    tableStart = lastTableOpen;
  } else {
    const afterTitle = html.substring(titleIdx);
    const tableMatch = afterTitle.match(/<table[\s>]/i);
    if (!tableMatch) return null;
    tableStart = titleIdx + tableMatch.index;
  }
  let depth = 0, tableEnd = -1, si = tableStart;
  while (si < html.length) {
    const om = html.substring(si).match(/<table[\s>]/i);
    const cm = html.substring(si).match(/<\/table>/i);
    if (!om && !cm) break;
    const op = om ? si + om.index : Infinity;
    const cp = cm ? si + cm.index : Infinity;
    if (op < cp) { depth++; si = op + 6; }
    else { depth--; if (depth === 0) { tableEnd = cp + 8; break; } si = cp + 8; }
  }
  if (tableEnd === -1) return null;
  return html.substring(tableStart, tableEnd);
}

function extractFromFile(filePath, fy, q) {
  const html = fs.readFileSync(filePath, 'utf-8');
  const result = {};

  // CF計算書テーブルを解析
  const tableHtml = findTable(html, 'CONDENSED CONSOLIDATED STATEMENTS OF CASH FLOWS');
  if (tableHtml) {
    const $ = cheerio.load(tableHtml);
    $('tr').each((i, row) => {
      const label = getRowLabel($, row);
      if (!label) return;
      const values = extractValues($, row);
      if (values.length === 0) return;
      const firstValue = parseNumber(values[0]);
      for (const mapping of CF_ROW_MAPPINGS) {
        if (mapping.patterns.some(p => p.test(label))) {
          if (!(mapping.key in result)) {
            result[mapping.key] = firstValue;
          }
          break;
        }
      }
    });
  }

  // FCFを計算 (OCF - CapEx)
  if (result.operatingCashFlow != null && result.capitalExpenditures != null) {
    result.freeCashFlow = result.operatingCashFlow - Math.abs(result.capitalExpenditures);
  }

  return Object.keys(result).length > 0 ? result : null;
}

/**
 * 累積CFデータを四半期データに変換
 * Apple: Q1=3ヶ月, Q2=6ヶ月累積, Q3=9ヶ月累積, Q4=12ヶ月累積
 * 四半期値 = 当期累積 - 前四半期累積
 */
function convertCumulativeToQuarterly(cumulativeData) {
  const result = {};
  const CF_KEYS = ['operatingCashFlow', 'investingCashFlow', 'financingCashFlow',
    'capitalExpenditures', 'shareRepurchases', 'dividendsPaid',
    'depreciationAndAmortization', 'shareBasedCompensation'];

  for (const fy of Object.keys(cumulativeData).sort()) {
    result[fy] = {};
    const quarters = ['Q1', 'Q2', 'Q3', 'Q4'];
    const prevQuarter = { Q2: 'Q1', Q3: 'Q2', Q4: 'Q3' };

    for (const q of quarters) {
      if (!cumulativeData[fy]?.[q]) continue;
      const cumData = cumulativeData[fy][q];

      if (q === 'Q1') {
        // Q1はそのまま（3ヶ月のみ）
        result[fy][q] = { ...cumData };
      } else {
        // Q2-Q4: 当期累積 - 前四半期累積
        const prevQ = prevQuarter[q];
        const prevData = cumulativeData[fy]?.[prevQ];
        if (!prevData) {
          // 前四半期データがない場合はそのまま
          result[fy][q] = { ...cumData };
          continue;
        }

        const quarterly = {};
        for (const key of CF_KEYS) {
          if (cumData[key] != null && prevData[key] != null) {
            quarterly[key] = cumData[key] - prevData[key];
          } else if (cumData[key] != null) {
            quarterly[key] = cumData[key];
          }
        }

        // FCFを再計算
        if (quarterly.operatingCashFlow != null && quarterly.capitalExpenditures != null) {
          quarterly.freeCashFlow = quarterly.operatingCashFlow - Math.abs(quarterly.capitalExpenditures);
        }

        result[fy][q] = quarterly;
      }
    }
  }

  return result;
}

// メイン処理
function main() {
  const cumulativeCashFlows = {};

  const fyDirs = fs.readdirSync(FILINGS_DIR)
    .filter(d => d.startsWith('FY') && fs.statSync(path.join(FILINGS_DIR, d)).isDirectory())
    .sort();

  for (const fy of fyDirs) {
    const fyPath = path.join(FILINGS_DIR, fy);
    const qDirs = fs.readdirSync(fyPath)
      .filter(d => d.startsWith('Q') && fs.statSync(path.join(fyPath, d)).isDirectory())
      .sort();

    for (const q of qDirs) {
      const prPath = path.join(fyPath, q, 'press-release.htm');
      if (!fs.existsSync(prPath)) continue;

      console.log(`処理中: ${fy}/${q}`);
      const data = extractFromFile(prPath, fy, q);
      if (data) {
        if (!cumulativeCashFlows[fy]) cumulativeCashFlows[fy] = {};
        cumulativeCashFlows[fy][q] = data;
        const keys = Object.keys(data);
        console.log(`  → [累積] ${keys.length} 項目: ${keys.map(k => `${k}=${data[k]}`).join(', ')}`);
      }
    }
  }

  // 累積 → 四半期変換
  console.log('\n累積データを四半期データに変換中...');
  const cashFlows = convertCumulativeToQuarterly(cumulativeCashFlows);

  // 変換結果を表示
  for (const fy of Object.keys(cashFlows).sort()) {
    for (const q of Object.keys(cashFlows[fy]).sort()) {
      const d = cashFlows[fy][q];
      console.log(`  ${fy}/${q}: OCF=${d.operatingCashFlow}, FCF=${d.freeCashFlow}, CapEx=${d.capitalExpenditures}`);
    }
  }

  fs.writeFileSync(OUTPUT_PATH, JSON.stringify(cashFlows, null, 2));
  console.log(`\n出力: ${OUTPUT_PATH}`);

  let total = 0;
  for (const fy of Object.keys(cashFlows)) {
    for (const q of Object.keys(cashFlows[fy])) total++;
  }
  console.log(`合計: ${total} 四半期分のCFデータを抽出`);
}

main();
